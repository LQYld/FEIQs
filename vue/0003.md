# 【Vue2系列】 经典面试题

## 1. 有使用过vue吗？说说你对vue的理解？

***Vue核心特性***
- ***数据驱动（MVVM)***
  - MVVM表示的是 Model-View-ViewModel
    - ***Model***：模型层，负责处理业务逻辑以及和服务器端进行交互
    - ***View***：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面
    - ***ViewModel***：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁
  - 组件化
    - 什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势
      - 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现
      - 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
      - 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级
  - 指令系统
    - 解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM
      - 常用的指令
        - 条件渲染指令 v-if
        - 列表渲染指令v-for
        - 属性绑定指令v-bind
        - 事件绑定指令v-on
        - 双向数据绑定指令v-model
  - Vue和React对比
    - 这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同
    - ***相同点***
      - 都有组件化思想
      - 都支持服务器端渲染
      - 都有Virtual DOM（虚拟dom）
      - 数据驱动视图
      - 都有支持native的方案：Vue的weex、React的React native
      - 都有自己的构建工具：Vue的vue-cli、React的Create React Apps
    - ***不同点***
      - 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流
      - 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据
      - 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数
      - diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM

> 参考文献
> - https://segmentfault.com/a/1190000016269636
> - https://zh.wikipedia.org/zh-cn/Vue.js
> - https://zhuanlan.zhihu.com/p/20197803
> - https://zhuanlan.zhihu.com/p/38296857

## 2. 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢
***什么是SPA***
SPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面
***SPA和MPA的区别***
|         | 单页面应用（SPA） | 多页面应用（MPA） |
|--|--|--|
|组成|一个主页面和多个页面片段|多个主页面|
|刷新方式|局部刷新|整页刷新|
|url模式|哈希模式|历史模式|
|SEO搜索引擎优化|难实现，可使用SSR方式改善|容易实现|
|数据传递|容易|通过url、cookie、localStorage等传递|
|页面切换|	速度快，用户体验良好|切换加载资源，速度慢，用户体验差|
|维护成本|相对容易|相对复杂|

***单页应用优缺点***

优点：
- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快，内容的改变不需要重新加载整个页面
- 良好的前后端分离，分工更明确

缺点：
- 不利于搜索引擎的抓取
- 首次渲染速度相对较慢

***如何给SPA做SEO***
- SSR服务端渲染
  - 将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js
- 静态化
  - 目前主流的静态化主要有两种：
    - 一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中
    - 另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果
- 使用Phantomjs针对爬虫处理
  - 原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫

> 参考文献
> - https://segmentfault.com/a/1190000019623624
> - https://juejin.cn/post/6844903512107663368
> - https://www.cnblogs.com/constantince/p/5586851.html

## 3. v-show和v-if有什么区别？使用场景分别是什么？

***v-show与v-if的共同点***
我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示

在用法上也是相同的
```vue
<Model v-show="isShow" />
<Model v-if="isShow" />
```
- 当表达式为true的时候，都会占据页面的位置
- 当表达式都为false时，都不会占据页面位置

***v-show与v-if的区别***
- 控制手段不同
- 编译过程不同
- 编译条件不同

***控制手段***：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除

***编译过程***：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换

***编译条件***：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染

- v-show 由false变为true的时候不会触发组件的生命周期
- v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法

性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

***v-show与v-if原理分析***
具体解析流程这里不展开讲，大致流程如下
- 将模板template转为ast结构的JS对象
- 用ast得到的JS对象拼装render和staticRenderFns函数
- render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息
- vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点

***v-show与v-if的使用场景***

v-if 与 v-show 都能控制dom元素在页面的显示

v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）

如果需要非常频繁地切换，则使用 v-show 较好

如果在运行时条件很少改变，则使用 v-if 较好

> 参考文献
> - https://www.jianshu.com/p/7af8554d8f08
> - https://juejin.cn/post/6897948855904501768
> - https://vue3js/docs/zh